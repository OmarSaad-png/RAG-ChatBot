ns and policies interact similarly to dynamic programming to achieveoptimality, first addressing the prediction problem and then extending to policy improvement and control, all based on sampled experience.[14]Temporal difference methods[edit]Main article:Temporal difference learningThe first problem is corrected by allowing the procedure to change the policy (at some or all states) before the values settle. This too may be problematic as it might prevent convergence. Most current algorithms do this, giving rise to the class ofgeneralized policy iterationalgorithms. Manyactor-criticmethods belong to this category.The second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Sutton'stemporal difference(TD) methods that are based on the recursiveBellman equation.[16][17]The computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are batched and the estimates are computed once based on the batch). Batch methods, such as the least-squares temporal difference method,[18]may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue.Another problem specific to TD comes from their reliance on the recursive Bellman equation. Most TD methods have a so-called{\displaystyle \lambda }parameter(01){\displaystyle (0\leq \lambda \leq 1)}that can continuously interpolate between Monte Carlo methods that do not rely on the Bellman equations and the basic TD methods that rely entirely on the Bellman equations. This can be effective in palliating this issue.Function approximation methods[edit]In order to address the fifth issue,function approximation methodsare used.Linear function approximationstarts with a mapping{\displaystyle \phi }that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair(s,a){\displaystyle (s,a)}are obtained by linearly combining the components of(s,a){\displaystyle \phi (s,a)}with someweights{\displaystyle \theta }:Q(s,a)=i=1dii(s,a).{\displaystyle Q(s,a)=\sum _{i=1}^{d}\theta _{i}\phi _{i}(s,a).}The algorithms then adjust the weights, instead of adjusting the values associated with the individual state-action pairs. Methods based on ideas fromnonparametric statistics(which can be seen to construct their own features) have been explored.Value iteration can also be used as a starting point, giving rise to theQ-learningalgorithm and its many variants.[19]Including Deep Q-learning methods when a neural network is used to represent Q, with various applications in stochastic search problems.[20]The problem with using action-values is that they may need highly precise estimates of the competing action values that can be hard to obtain when the returns are noisy, though this problem is mitigated to some extent by temporal difference methods. Using the so-called compatible function approximation method compromises generality and efficiency.Direct policy search[edit]An alternative method is to search directly in (some subset of) the policy space, in which case the problem becomes a case ofstochastic optimization. The two approaches available are gradient-based and gradient-free methods.Gradient-based methods (policy gradient methods) start with a mapping from a finite-dimensional (parameter) space to the space of policies: given the parameter vector{\displaystyle \theta }, let{\displaystyle \pi _{\theta }}denote the policy associated to{\displaystyle \theta }. Defining the performance function by()={\displaystyle \rho (\theta )=\rho ^{\pi _{\theta }}}under mild conditions this function will be differentiable as a function of the parameter vector{\displaystyle \theta }. If the gradient of{\displaystyle \rho }was known, one could usegradient ascent. Since an analytic expression for the gradient is not available, only a noisy estimate is available. Such an estimate can be constructed in many ways, giving rise to algorithms such as Williams' REINFORCE method[21](which is known as the likelihood ratio method in thesimulation-based optimizationliterature).[22]A large class of methods avoids relying on gradient information. These includesimulated annealing,cross-entropy searchor methods ofevolutionary computation. Many gradient-free methods can achieve (in theory and in the limit) a global optimum.Policy search methods may converge slowly given noisy data. For example, this happens in episodic problems when the trajectories are long and the variance of the returns is large. Value-function based methods that rely on temporal differences might help in this case. In rec