mal action-value function arevalue iterationandpolicy iteration. Both algorithms compute a sequence of functionsQk{\displaystyle Q_{k}}(k=0,1,2,{\displaystyle k=0,1,2,\ldots }) that converge toQ{\displaystyle Q^{*}}. Computing these functions involves computing expectations over the whole state-space, which is impractical for all but the smallest (finite) Markov decision processes. In reinforcement learning methods, expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large state-action spaces.Monte Carlo methods[edit]Monte Carlo methods[15]are used to solve reinforcement learning problems by averaging sample returns. Unlike methods that require full knowledge of the environments dynamics, Monte Carlo methods rely solely on actual orsimulatedexperiencesequences of states, actions, and rewards obtained from interaction with an environment. This makes them applicable in situations where the complete dynamics are unknown. Learning from actual experience does not require prior knowledge of the environment and can still lead to optimal behavior. When using simulated experience, only a model capable of generating sample transitions is required, rather than a full specification oftransition probabilities, which is necessary fordynamic programmingmethods.Monte Carlo methods apply to episodic tasks, where experience is divided into episodes that eventually terminate. Policy and value function updates occur only after the completion of an episode, making these methods incremental on an episode-by-episode basis, though not on a step-by-step (online) basis. The term Monte Carlo generally refers to any method involvingrandom sampling; however, in this context, it specifically refers to methods that compute averages fromcompletereturns, rather thanpartialreturns.These methods function similarly to thebandit algorithms, in which returns are averaged for each state-action pair. The key difference is that actions taken in one state affect the returns of subsequent states within the same episode, making the problemnon-stationary. To address this non-stationarity, Monte Carlo methods use the framework of general policy iteration (GPI). While dynamic programming computesvalue functionsusing full knowledge of theMarkov decision process(MDP), Monte Carlo methods learn these functions through sample returns. The value functions and policies interact similarly to dynamic programming to achieveoptimality, first addressing the prediction problem and then extending to policy improvement and control, all based on sampled experience.[14]Temporal difference methods[edit]Main article:Temporal difference learningThe first problem is corrected by allowing the procedure to change the policy (at some or all states) before the values settle. This too may be problematic as it might prevent convergence. Most current algorithms do this, giving rise to the class ofgeneralized policy iterationalgorithms. Manyactor-criticmethods belong to this category.The second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Sutton'stemporal difference(TD) methods that are based on the recursiveBellman equation.[16][17]The computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are batched and the estimates are computed once based on the batch). Batch methods, such as the least-squares temporal difference method,[18]may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue.Another problem specific to TD comes from their reliance on the recursive Bellman equation. Most TD methods have a so-called{\displaystyle \lambda }parameter(01){\displaystyle (0\leq \lambda \leq 1)}that can continuously interpolate between Monte Carlo methods that do not rely on the Bellman equations and the basic TD methods that rely entirely on the Bellman equations. This can be effective in palliating this issue.Function approximation methods[edit]In order to address the fifth issue,function approximation methodsare used.Linear function approximationstarts with a mapping{\displaystyle \phi }that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair(s,a){\displaystyle (s,a)}are obtained by linearly combining the components of(s,a){\displaystyle \phi (s,a)}with someweights{\displaystyle \theta }:Q(s,a)=i=1dii(s,a).{\displaystyle Q(s,a)=\sum _{i=1}^{d}\theta _{i}\phi _{i}(s,a).}The algorithms then adjust the weights, instead of adjus