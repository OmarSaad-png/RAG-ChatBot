on the theory of Markov decision processes, where optimality is defined in a sense stronger than the one above: A policy is optimal if it achieves the best-expected discounted return fromanyinitial state (i.e., initial distributions play no role in this definition). Again, an optimal policy can always be found among stationary policies.To define optimality in a formal manner, define the state-value of a policy{\displaystyle \pi }byV(s)=E[Gs,],{\displaystyle V^{\pi }(s)=\operatorname {\mathbb {E} } [G\mid s,\pi ],}whereG{\displaystyle G}stands for the discounted return associated with following{\displaystyle \pi }from the initial states{\displaystyle s}. DefiningV(s){\displaystyle V^{*}(s)}as the maximum possible state-value ofV(s){\displaystyle V^{\pi }(s)}, where{\displaystyle \pi }is allowed to change,V(s)=maxV(s).{\displaystyle V^{*}(s)=\max _{\pi }V^{\pi }(s).}A policy that achieves these optimal state-values in each state is calledoptimal. Clearly, a policy that is optimal in this sense is also optimal in the sense that it maximizes the expected discounted return, sinceV(s)=maxE[Gs,]{\displaystyle V^{*}(s)=\max _{\pi }\mathbb {E} [G\mid s,\pi ]}, wheres{\displaystyle s}is a state randomly sampled from the distribution{\displaystyle \mu }of initial states (so(s)=Pr(S0=s){\displaystyle \mu (s)=\Pr(S_{0}=s)}).Although state-values suffice to define optimality, it is useful to define action-values. Given a states{\displaystyle s}, an actiona{\displaystyle a}and a policy{\displaystyle \pi }, the action-value of the pair(s,a){\displaystyle (s,a)}under{\displaystyle \pi }is defined byQ(s,a)=E[Gs,a,],{\displaystyle Q^{\pi }(s,a)=\operatorname {\mathbb {E} } [G\mid s,a,\pi ],\,}whereG{\displaystyle G}now stands for the random discounted return associated with first taking actiona{\displaystyle a}in states{\displaystyle s}and following{\displaystyle \pi }, thereafter.The theory of Markov decision processes states that if{\displaystyle \pi ^{*}}is an optimal policy, we act optimally (take the optimal action) by choosing the action fromQ(s,){\displaystyle Q^{\pi ^{*}}(s,\cdot )}with the highest action-value at each state,s{\displaystyle s}. Theaction-value functionof such an optimal policy (Q{\displaystyle Q^{\pi ^{*}}}) is called theoptimal action-value functionand is commonly denoted byQ{\displaystyle Q^{*}}. In summary, the knowledge of the optimal action-value function alone suffices to know how to act optimally.Assuming full knowledge of the Markov decision process, the two basic approaches to compute the optimal action-value function arevalue iterationandpolicy iteration. Both algorithms compute a sequence of functionsQk{\displaystyle Q_{k}}(k=0,1,2,{\displaystyle k=0,1,2,\ldots }) that converge toQ{\displaystyle Q^{*}}. Computing these functions involves computing expectations over the whole state-space, which is impractical for all but the smallest (finite) Markov decision processes. In reinforcement learning methods, expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large state-action spaces.Monte Carlo methods[edit]Monte Carlo methods[15]are used to solve reinforcement learning problems by averaging sample returns. Unlike methods that require full knowledge of the environments dynamics, Monte Carlo methods rely solely on actual orsimulatedexperiencesequences of states, actions, and rewards obtained from interaction with an environment. This makes them applicable in situations where the complete dynamics are unknown. Learning from actual experience does not require prior knowledge of the environment and can still lead to optimal behavior. When using simulated experience, only a model capable of generating sample transitions is required, rather than a full specification oftransition probabilities, which is necessary fordynamic programmingmethods.Monte Carlo methods apply to episodic tasks, where experience is divided into episodes that eventually terminate. Policy and value function updates occur only after the completion of an episode, making these methods incremental on an episode-by-episode basis, though not on a step-by-step (online) basis. The term Monte Carlo generally refers to any method involvingrandom sampling; however, in this context, it specifically refers to methods that compute averages fromcompletereturns, rather thanpartialreturns.These methods function similarly to thebandit algorithms, in which returns are averaged for each state-action pair. The key difference is that actions taken in one state affect the returns of subsequent states within the same episode, making the problemnon-stationary. To address this non-stationarity, Monte Carlo methods use the framework of general policy iteration (GPI). While dynamic programming computesvalue functionsusing full knowledge of theMarkov decision process(MDP), Monte Carlo methods learn these functions through sample returns. The value functio